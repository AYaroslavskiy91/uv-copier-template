import builtins
import os
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from collections.abc import Callable, Generator, Iterable, Iterator
from typing import IO, Any, AnyStr, LiteralString, Self

FLAGS: dict[str, int]

class FSUser(int):
    name: Incomplete
    def __new__(cls, val, name: Incomplete | None = None) -> Self: ...

class Path(str, ABC):
    CASE_SENSITIVE: bool
    def __truediv__(self, other: Incomplete) -> Self: ...
    def __getitem__(self, key) -> Self | str: ...
    def __floordiv__(self, expr: str | Iterable[str]) -> builtins.list[Self]: ...
    def __iter__(self) -> Iterator[Self]: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __fspath__(self) -> str: ...
    def __contains__(self, item) -> bool: ...
    def up(self, count: int = 1) -> Self: ...
    def walk(
        self,
        filter: Callable[[Path], bool] = ...,
        dir_filter: Callable[[Path], bool] = ...,
    ) -> Generator[Self, Incomplete, None]: ...
    @property
    @abstractmethod
    def name(self) -> str: ...
    @property
    def basename(self) -> str: ...
    @property
    @abstractmethod
    def stem(self) -> str: ...
    @property
    @abstractmethod
    def dirname(self) -> Self: ...
    @property
    @abstractmethod
    def root(self) -> str: ...
    @property
    @abstractmethod
    def drive(self) -> str: ...
    @property
    @abstractmethod
    def suffix(self) -> str: ...
    @property
    @abstractmethod
    def suffixes(self) -> builtins.list[str]: ...
    @property
    @abstractmethod
    def uid(self) -> FSUser: ...
    @property
    @abstractmethod
    def gid(self) -> FSUser: ...
    @abstractmethod
    def as_uri(self, scheme: str | None = None) -> str: ...
    @abstractmethod
    def join(self, *parts) -> Self: ...
    @abstractmethod
    def list(self) -> builtins.list[Self]: ...
    @abstractmethod
    def iterdir(self: Self) -> Iterable[Self]: ...
    @abstractmethod
    def is_dir(self) -> bool: ...
    def isdir(self):  # -> bool:
        ...
    @abstractmethod
    def is_file(self) -> bool: ...
    def isfile(self) -> bool: ...
    def islink(self) -> bool: ...
    @abstractmethod
    def is_symlink(self) -> bool: ...
    @abstractmethod
    def exists(self) -> bool: ...
    @abstractmethod
    def stat(self) -> os.stat_result: ...
    @abstractmethod
    def with_name(self, name: Incomplete) -> Self: ...
    @abstractmethod
    def with_suffix(self, suffix: str, depth: int | None = 1) -> Self: ...
    def preferred_suffix(self, suffix: str) -> Self: ...
    @abstractmethod
    def glob(self, pattern: str | Iterable[str]) -> builtins.list[Self]: ...
    @abstractmethod
    def delete(self): ...
    @abstractmethod
    def move(self, dst): ...
    def rename(self, newname): ...
    @abstractmethod
    def copy(self, dst, override: bool | None = None): ...
    @abstractmethod
    def mkdir(self, mode: int = 0o777, parents: bool = True, exist_ok: bool = True): ...
    @abstractmethod
    def open(self, mode: str = "r", *, encoding: str | None = None) -> IO[Any]: ...
    @abstractmethod
    def read(self, encoding: str | None = None) -> str: ...
    @abstractmethod
    def write(self, data: AnyStr, encoding: str | None = None) -> None: ...
    @abstractmethod
    def touch(self): ...
    @abstractmethod
    def chown(
        self,
        owner: Incomplete | None = None,
        group: Incomplete | None = None,
        recursive: bool | None = None,
    ): ...
    @abstractmethod
    def chmod(self, mode): ...
    @abstractmethod
    def access(self, mode: int | str = 0) -> bool: ...
    @abstractmethod
    def link(self, dst): ...
    @abstractmethod
    def symlink(self, dst): ...
    @abstractmethod
    def unlink(self): ...
    def split(self, *_args, **_kargs) -> builtins.list[str]: ...
    @property
    def parts(self) -> tuple[str, ...]: ...
    def relative_to(self, source: Self | str) -> RelativePath: ...
    def __sub__(self, other: Self | str) -> RelativePath: ...
    def resolve(self, strict: bool = False) -> Self: ...
    @property
    def parents(self) -> tuple[Self, ...]: ...
    @property
    def parent(self) -> Self: ...

class RelativePath:
    parts: Iterable[LiteralString]
    def __init__(self, parts: Iterable[LiteralString]) -> None: ...
    def __iter__(self) -> Iterator[LiteralString]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> LiteralString: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def up(self, count: int = 1) -> RelativePath: ...
    def __radd__(self, path): ...
