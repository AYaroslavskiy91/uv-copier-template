import builtins
from _typeshed import Incomplete
from collections.abc import Generator, Iterable
from contextlib import AbstractContextManager
from typing import Any, Literal, Never, Self

from plumbum.commands import ProcessExecutionError as ProcessExecutionError
from plumbum.commands import shquote as shquote
from plumbum.path.base import FSUser, Path

class StatRes:
    def __init__(self, tup: Iterable) -> None: ...
    def __getitem__(self, index: int | slice) -> Incomplete: ...
    st_mode: property
    mode: property
    st_ino: property
    ino: property
    st_dev: property
    dev: property
    st_nlink: property
    nlink: property
    st_uid: property
    uid: property
    st_gid: property
    gid: property
    st_size: property
    size: property
    st_atime: property
    atime: property
    st_mtime: property
    mtime: property
    st_ctime: property
    ctime: property

class RemotePath(Path):
    CASE_SENSITIVE: bool
    remote: Incomplete
    def __new__(cls, remote, *parts) -> Self: ...
    @property
    def name(self) -> str: ...
    # ``dirname`` stub is accurate even if implementation violates ABC
    @property
    def dirname(self) -> str | Self: ...  # type: ignore[override]
    @property
    def suffix(self) -> str: ...
    @property
    def suffixes(self) -> builtins.list[str]: ...
    @property
    def uid(self) -> FSUser: ...
    @property
    def gid(self) -> FSUser: ...
    def join(self, *parts) -> RemotePath: ...
    def list(self) -> builtins.list[RemotePath]: ...
    def iterdir(self) -> tuple[()] | Generator[RemotePath, None, None]: ...
    def is_dir(self) -> bool: ...
    def is_file(self) -> bool: ...
    def is_symlink(self) -> bool: ...
    def exists(self) -> bool: ...
    # FIXME: define type that encompases ``os.stat_result`` & ``StatRes``?
    def stat(self) -> StatRes: ...  # type: ignore[override]
    def with_name(self, name: Incomplete) -> Self: ...
    def with_suffix(self, suffix: str, depth: int | None = 1) -> Self: ...
    def glob(self, pattern) -> builtins.list[Any]: ...
    def delete(self) -> None: ...

    unlink = delete
    def move(self, dst) -> None: ...
    def copy(self, dst, override: bool | None = None) -> None: ...
    def mkdir(
        self,
        mode: Incomplete | None = None,
        parents: bool = True,
        exist_ok: bool = True,
    ) -> None: ...
    def read(self, encoding: Incomplete | None = None) -> Incomplete: ...
    def write(self, data, encoding: Incomplete | None = None) -> None: ...
    def touch(self) -> None: ...
    def chown(
        self,
        owner: Incomplete | None = None,
        group: Incomplete | None = None,
        recursive: Incomplete | None = None,
    ) -> None: ...
    def chmod(self, mode) -> None: ...
    def access(self, mode: int | str = 0) -> bool: ...
    def link(self, dst):  # -> None:
        ...
    def symlink(self, dst) -> None: ...
    def open(
        self, mode: str = "r", bufsize: int = -1, *, encoding: Incomplete | None = None
    ) -> Incomplete: ...
    # implementation will render ``None`` in a format string... probably not desired
    def as_uri(self, scheme: str = "ssh") -> str: ...  # type: ignore[override]
    @property
    def stem(self) -> str: ...
    @property
    def root(self) -> Literal["/"]: ...
    @property
    def drive(self) -> Literal[""]: ...

class RemoteWorkdir(RemotePath):
    def __new__(cls, remote) -> Self: ...
    def __hash__(self) -> Never: ...
    def chdir(self, newdir) -> type[Self]: ...
    def getpath(self) -> RemotePath: ...
    def __call__(self, newdir) -> AbstractContextManager[Self]: ...
